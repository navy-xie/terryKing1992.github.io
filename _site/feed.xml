<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Terry.King的技术博客</title>
    <description>欢迎来到我的技术博客，我是Terry.King</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 19 Jun 2017 23:59:13 +0800</pubDate>
    <lastBuildDate>Mon, 19 Jun 2017 23:59:13 +0800</lastBuildDate>
    <generator>Jekyll v3.4.0</generator>
    
      <item>
        <title>Runloop官方解释</title>
        <description>&lt;p&gt;#前言&lt;/p&gt;

&lt;p&gt;从2014年8月到公司报到，然后跟着导师维护Android SDK，再到后面跟着另外一名大牛Lance(曾经在Nokia
芬兰总部、三星韩国总部工作，对于三维建模，10年的OpenGL开发经验) 学习IOS 的开发，
并且跟着项目走并且有人指导成长相对来说还是比较快的。但是对于接受新知识的能力还不足，具体表现在英语非常的不好；
而当时学习IOS的时候Lance和其他同事也是强烈建议读官方文档的，不过我却认为对于初学者 如果不是想紧随时代的步伐
(当然这也不会是一个好的程序员)，首先需要的是入门，而不是啃硬骨头。到现在有些知识理解了，并且经常实践了才会知道后面的原理。
当大概知道了某一些原理了之后再去读相关的官方文档，这样的好处是：第一：能够快速入门，不至于在没有入门的时候就丧失自信；
第二：对于自己理解有偏差的地方可以纠正；第三：对于自己的英文能力也是一种提高。而后面也可以跟着技术的步伐向前走了。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;#Runloop是什么&lt;/p&gt;

&lt;p&gt;Run loops are part of the fundamental infrastructure associated with threads.
A run loop is an event processing loop that you use to schedule work
and coordinate the receipt of incoming events. The purpose of a run loop is to
keep your thread busy when there is work to do and put your thread to sleep when there is none.&lt;/p&gt;

&lt;p&gt;Runloop是与多线程相关的、基础框架中非常重要的一部分。
Runloop是你用来调度、协调当前的到来事件的一个循环。Runloop的目的就是当有任务到来的时候保持当前线程处于繁忙状态，
当没有任务需要处理的时候让当前线程处于休眠状态。&lt;/p&gt;

&lt;p&gt;Run loop management is not entirely automatic.
You must still design your thread’s code to start the run loop at appropriate times
and respond to incoming events. Both Cocoa and Core Foundation provide run loop objects
to help you configure and manage your thread’s run loop.
Your application does not need to create these objects explicitly;
each thread, including the application’s main thread, has an associated run loop object.
Only secondary threads need to run their run loop explicitly, however.
The app frameworks automatically set up and run the run loop on the main thread as part
	of the application startup process.&lt;/p&gt;

&lt;p&gt;Runloop 管理不是完全自动的。你还需要设计线程相关的代码 并且 在合适的时机开启当前线程的Runloop 去响应即将到来的事件。
不过还好 cocoa 和 core foundation框架都提供了一系列与runloop相关的对象让我们能够配置和管理线程的runloop。
我们的应用程序不需要显试的创建这些对象。每一个线程(包括主线程)都关联了一个runloop对象，
只有非主线程才需要显示的开启runloop处理不同数据源的事件。不过主线程的Runloop与非主线程不同，
应用程序在启动的时候就会自动的创建Runloop 并且跟着 应用的启动进程一起 启动并且运行在主线程。&lt;/p&gt;

&lt;p&gt;The following sections provide more information about run loops and
how you configure them for your application.
For additional information about run loop objects, see NSRunLoop Class Reference and CFRunLoop Reference.&lt;/p&gt;

&lt;p&gt;后面的章节将会告诉你关于run loop的更多信息 以及 如何在你的应用中配置runloop。
对于其他runloop 相关对象，请参考NSRunLoop 以及 CFRunLoop。&lt;/p&gt;

&lt;p&gt;#Anatomy of a Run Loop(RunLoop分解)&lt;/p&gt;

&lt;p&gt;A run loop is very much like its name sounds.
It is a loop your thread enters and uses to run event handlers in response to incoming events.
Your code provides the control statements used to implement the actual loop portion of the run loop—in other words,
your code provides the while or for loop that drives the run loop.
Within your loop, you use a run loop object to “run” the event-processing code
that receives events and calls the installed handlers.&lt;/p&gt;

&lt;p&gt;RunLoop 的功能 与 它的名字十分相符。Runloop 用来响应 即将到来的事件，并且运行事件处理逻辑 响应相关事件。
你的代码提供了真正实现runloop的控制语句—换句话说，你的代码需要提供while循环或者for循环来驱动runLoop才可以让RunLoop处理事件。
在Runloop中，你需要使用一个runloop对象来”运行” 能够接收事件并且调用处理逻辑的 事件处理的代码。
RunLoop接收的事件来自于两个地方；第一:输入源 传递异步事件，一般来说 是来自其他线程 或者 其他应用的消息
第二:定时器源 传递同步事件 当timer调度开始的时候。这两种输入源都是用系统已经指定号的处理对象 来处理这些事件。&lt;/p&gt;

&lt;p&gt;Figure 3-1 shows the conceptual structure of a run loop and a variety of sources.
The input sources deliver asynchronous events to the corresponding handlers
and cause the runUntilDate: method (called on the thread’s associated NSRunLoop object) to exit.
Timer sources deliver events to their handler routines but do not cause the run loop to exit.&lt;/p&gt;

&lt;p&gt;如下图显示了Runloop概念结构图 和 多种多样的数据源。输入源传输异步事件到相应的处理模块
并且 使runUntilDate方法退出。定时器源 传递事件 到他们对应的处理模块，但是不会造成当前runloop退出。&lt;/p&gt;

&lt;p&gt;In addition to handling sources of input, run loops also generate notifications
 about the run loop’s behavior. Registered run-loop observers can receive these notifications
 and use them to do additional processing on the thread.
 You use Core Foundation to install run-loop observers on your threads.&lt;/p&gt;

&lt;p&gt;除了处理输入类型的事件之外，Runloop还会生成关于 Runloop相关行为的通知。
已经注册的Runloop的观察者 能够接收相应的 通知 并且在当前线程中处理额外的事情。
你可以使用Core Foundation中的方法 来 在你的线程中 注册相关的观察者 来处理不同的事件。&lt;/p&gt;

&lt;p&gt;The following sections provide more information about the components of a run loop
and the modes in which they operate. They also describe the notifications
that are generated at different times during the handling of events&lt;/p&gt;

&lt;p&gt;下面的段落 将提供 关于Runloop 组成的更多信息 以及 Runloop组成部分在哪种模式下运行。
下面还会描述 在处理不同的事件时产生的各种通知。&lt;/p&gt;

&lt;p&gt;#Run Loop Modes (Runloop 运行模式)&lt;/p&gt;

&lt;p&gt;A run loop mode is a collection of input sources and timers to be monitored
and a collection of run loop observers to be notified. Each time you run your run loop,
you specify (either explicitly or implicitly) a particular “mode” in which to run.
During that pass of the run loop, only sources associated with that mode are monitored and
allowed to deliver their events.
(Similarly, only observers associated with that mode are notified of the run loop’s progress.)
Sources associated with other modes hold on to any new events
until subsequent passes through the loop in the appropriate mode.&lt;/p&gt;

&lt;p&gt;Runloop 模式 是一个集合，这个集合包含了 需要监控的输入源以及需要通知的观察者。
每次当你运行你的RunLoop，你都需要显式或者隐式的指定 当前线程所运行的模式。经过一次RunLoop之后，
只有与该 模式相关的 事件源才能被监听 以及 传递他们的事件。同样的，只有在当前模式下面的观察者才会被通知。
其他模式下的事件源，需要Hold住，并且当当前的Runloop 运行在 与挂起的事件源对应模式下面的时候，才会被处理。&lt;/p&gt;

&lt;p&gt;In your code, you identify modes by name.
Both Cocoa and Core Foundation define a default mode and several commonly used modes,
along with strings for specifying those modes in your code.
You can define custom modes by simply specifying a custom string for the mode name.
Although the names you assign to custom modes are arbitrary, the contents of those modes are not.
You must be sure to add one or more input sources, timers,
or run-loop observers to any modes you create for them to be useful&lt;/p&gt;

&lt;p&gt;在你的代码中，你需要根据名称指定线程RunLoop运行的模式。Cocoa 以及 CoreFoundation框架定义了一个默认的模式 以及一些常用的模式，
不过也需要在代码中通过字符串来指定这些模式。当然，你也可以自己设计特定的模式 通过指定自定义的字符串 当做 Mode的名称。
尽管你指定的的模式的名字是任意的，但是模式的内容却不是任意的。你必须为你自定义的模式 添加输入源 或者定时器 或者RunLoop 观察者 来确保Runloop可用。&lt;/p&gt;

&lt;p&gt;You use modes to filter out events from unwanted sources during a particular pass through your run loop.
Most of the time, you will want to run your run loop in the system-defined “default” mode.
A modal panel, however, might run in the “modal” mode. While in this mode,
only sources relevant to the modal panel would deliver events to the thread. For secondary threads,
you might use custom modes to prevent low-priority sources from delivering events during time-critical operations.&lt;/p&gt;

&lt;p&gt;当在一次循环中，你可以通过这些模式来过滤不想要的事件源。大部分时间，你都可以将你的runloop运行在默认模式下面，不过，
特殊场景需要运行在特殊的模式下才可以。对于非主线程，你需要使用自定义模式 来避免低优先级的事件源也 在一次循环中被处理。&lt;/p&gt;

&lt;p&gt;Note: Modes discriminate based on the source of the event, not the type of the event.
For example, you would not use modes to match only mouse-down events or only keyboard events.
You could use modes to listen to a different set of ports, suspend timers temporarily,
or otherwise change the sources and run loop observers currently being monitored.&lt;/p&gt;

&lt;p&gt;需要提醒的是：模式 只区分了 基于 事件的源，而并不指定事件的类型。举个栗子：你不能使用Modes来匹配鼠标的点击事件或者键盘事件。
你只可以使用模式 去监听一个端口的集合、暂时挂起的定时器、或者其他改变源 以及当前 被监听的RunLoop观察者。&lt;/p&gt;

&lt;p&gt;#Input Source (输入源)&lt;/p&gt;

&lt;p&gt;Input sources deliver events asynchronously to your threads. The source of the event depends on the type of the input source, which is generally one of two categories. Port-based input sources monitor your application’s Mach ports. Custom input sources monitor custom sources of events. As far as your run loop is concerned, it should not matter whether an input source is port-based or custom. The system typically implements input sources of both types that you can use as is. The only difference between the two sources is how they are signaled. Port-based sources are signaled automatically by the kernel, and custom sources must be signaled manually from another thread。&lt;/p&gt;

&lt;p&gt;输入源 异步传递事件到你的线程中。事件源 取决于于某种特定类型的输入源，输入源有两种类型。第一种是基于端口的输入源监听你的应用程序的端口。自定义输入源监听自定义事件类型。只要你的RunLoop被输入源关联，RunLoop不关心到底是输入源还是自定义的。系统默认实现了两种类型的输入源供你使用。两种输入源之间的不同点就是一个需要信号通知，一个不需要。基于端口的输入源系统会自动发出信号，而自定义的输入源必须手动的在另外一个线程中手动发起信号。&lt;/p&gt;

&lt;p&gt;When you create an input source, you assign it to one or more modes of your run loop. Modes affect which input sources are monitored at any given moment. Most of the time, you run the run loop in the default mode, but you can specify custom modes too. If an input source is not in the currently monitored mode, any events it generates are held until the run loop runs in the correct mode.&lt;/p&gt;

&lt;p&gt;当你创建一个输入源的时候，你会将一个或者多个运行模式 赋值给你的RunLoop。运行模式 决定了在 某个特定的时候什么样的输入源会被监听以及调用。大部分情况下，你的RunLoop会运行在默认模式下，但是你也可以指定你自定义的模式。如果你的输入源不在当前监控的模式下，所有不在当前RunLoop运行模式下的事件都将会挂起，直到 RunLoop运行在正确的模式下才会得到执行。&lt;/p&gt;

&lt;p&gt;##Port-Based Sources(基于端口的源)&lt;/p&gt;

&lt;p&gt;Cocoa and Core Foundation provide built-in support for creating port-based input sources using port-related objects and functions. For example, in Cocoa, you never have to create an input source directly at all. You simply create a port object and use the methods of NSPort to add that port to the run loop. The port object handles the creation and configuration of the needed input source for you.&lt;/p&gt;

&lt;p&gt;Cocoa 和 Core Foundation 为创建基于 端口的输入源 提供了API，只要你使用与端口相关的对象以及方法。例如：在Cocoa中，你并不需要直接创建一个输入源。你只需要简单的创建一个端口对象NSPort 以及使用NSPort中的一些方法，并且把该端口正在到RunLoop中即可。该端口对象会自动创建以及配置输入源所需要的一切。&lt;/p&gt;

&lt;p&gt;In Core Foundation, you must manually create both the port and its run loop source. In both cases, you use the functions associated with the port opaque type (CFMachPortRef, CFMessagePortRef, or CFSocketRef) to create the appropriate objects.&lt;/p&gt;

&lt;p&gt;在CoreFoundation框架中，你必须要手动的创建端口以及 RunLoop的事件源。你可以使用CFMachPortRef,CFMessagePortRef 以及CFSocketRef来创建合适的对象。&lt;/p&gt;

&lt;p&gt;For examples of how to set up and configure custom port-based sources, see Configuring a Port-Based Input Source.&lt;/p&gt;

&lt;p&gt;大家可以看如何创建以及配置一个自定义的基于端口类型的输入源,可以查看配置基于端口的输入源这一章。&lt;/p&gt;

&lt;p&gt;##Custom Input Sources&lt;/p&gt;

&lt;p&gt;To create a custom input source, you must use the functions associated with the CFRunLoopSourceRef opaque type in Core Foundation. You configure a custom input source using several callback functions. Core Foundation calls these functions at different points to configure the source, handle any incoming events, and tear down the source when it is removed from the run loop.&lt;/p&gt;

&lt;p&gt;为了创建一个自定义的输入源，你需要使用在CoreFoundation中定义的CFRunLoopSourceRef类型。你需要使用多个回调函数来定义数据源。CoreFoundation在不同的时候调用这些方法来配置输入源，处理即将到来的时间以及销毁输入源当它从RunLoop中移除的时候。&lt;/p&gt;

&lt;p&gt;In addition to defining the behavior of the custom source when an event arrives, you must also define the event delivery mechanism. This part of the source runs on a separate thread and is responsible for providing the input source with its data and for signaling it when that data is ready for processing. The event delivery mechanism is up to you but need not be overly complex.&lt;/p&gt;

&lt;p&gt;另外，如果要为事件源定义当事件到来时候的行为，你需要定义事件的传递机制。这种机制运行在一个独立的线程中，根据输入源提供的数据 以及 当数据已经就绪之后的信号通知 来响应该事件。事件传递机制是由你决定但是不适合过于复杂。&lt;/p&gt;

&lt;p&gt;For an example of how to create a custom input source, see Defining a Custom Input Source. For reference information for custom input sources, see also CFRunLoopSource Reference.&lt;/p&gt;

&lt;p&gt;如下面例子中如何创建一个输入源，请参考Defining a Custom Input Source。&lt;/p&gt;

&lt;p&gt;#Cocoa Perform Selector Sources&lt;/p&gt;

&lt;p&gt;In addition to port-based sources, Cocoa defines a custom input source that allows you to perform a selector on any thread. Like a port-based source, perform selector requests are serialized on the target thread, alleviating many of the synchronization problems that might occur with multiple methods being run on one thread. Unlike a port-based source, a perform selector source removes itself from the run loop after it performs its selector.&lt;/p&gt;

&lt;p&gt;另外,除了基于端口的事件源之外，Cocoa还定义了一个自定义的输入源，允许你将一个选择子丢到任意的线程中执行。与端口源一样，Perform Selector请求是在目标线程中串行执行的，为了避免多个方法同时运行在一个线程造成的同步问题。与端口源不同的一点是：perform selector事件源 会在调用完成之后自己从RunLoop中移除。&lt;/p&gt;

&lt;p&gt;When performing a selector on another thread, the target thread must have an active run loop. For threads you create, this means waiting until your code explicitly starts the run loop. Because the main thread starts its own run loop, however, you can begin issuing calls on that thread as soon as the application calls the applicationDidFinishLaunching: method of the application delegate. The run loop processes all queued perform selector calls each time through the loop, rather than processing one during each loop iteration.&lt;/p&gt;

&lt;p&gt;当在另外一个线程执行一个选择子的时候，目标线程必须有一个活跃的RunLoop。对于我们自己创建的线程，这意味着我们需要手动的开启RunLoop。因为主线程会自动开启它自己的RunLoop,但是你可以把mainThread 作为你的执行对象 只要在app 之执行了applicationDidFinishLaunching这个方法。RunLoop执行所有被放到队列中的选择子在RunLoop的每一次执行的时候，而不是经过一次RunLoop才会执行一个选择子。&lt;/p&gt;

&lt;p&gt;Table 3-2 lists the methods defined on NSObject that can be used to perform selectors on other threads. Because these methods are declared on NSObject, you can use them from any threads where you have access to Objective-C objects, including POSIX threads. These methods do not actually create a new thread to perform the selector&lt;/p&gt;

&lt;p&gt;表3-2中列出了NSObject定义的用来在其他线程中执行选择子的方法。因为这些方法定义在NSObject中，所以你可以在任意的线程中使用它，只要你能够访问OC对象，包括POSIX 线程。这些方法不会为了执行selector而创建一个新的线程。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//Performs the specified selector on the application’s main thread during that thread’s next run loop cycle. These methods give you the option of blocking the current thread until the selector is performed.

//执行一个特定的selector在应用的主线程的下一个RunLoop循环中。这些方法会阻塞当前线程知道selector执行完成。

performSelectorOnMainThread:withObject:waitUntilDone:
performSelectorOnMainThread:withObject:waitUntilDone:modes:


//Performs the specified selector on any thread for which you have an NSThread object. These methods give you the option of blocking the current thread until the selector is performed.

//执行一个特定的selector在任意线程，该线程中一定有一个NSThread对象。这些方法也会阻塞当前线程，知道选择子执行完成。

performSelector:onThread:withObject:waitUntilDone:
performSelector:onThread:withObject:waitUntilDone:modes:

//Performs the specified selector on the current thread during the next run loop cycle and after an optional delay period. Because it waits until the next run loop cycle to perform the selector, these methods provide an automatic mini delay from the currently executing code. Multiple queued selectors are performed one after another in the order they were queued.

//经过一定时间的延迟之后会在当前线程的下一次RunLoop循环中执行一个特定的selector。因为它需要等待直到下一次RunLoop循环去执行这个selector，所以下面的两个方法提供了自动延迟机制。多个被放到队列中的选择器进行一个接一个的顺序执行。
performSelector:withObject:afterDelay:
performSelector:withObject:afterDelay:inModes:

Lets you cancel a message sent to the current thread using the performSelector:withObject:afterDelay: or performSelector:withObject:afterDelay:inModes: method

让我们能够取消调用上面的接口发送到当前线程的消息

cancelPreviousPerformRequestsWithTarget:
cancelPreviousPerformRequestsWithTarget:selector:object:
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 21 Apr 2016 05:46:52 +0800</pubDate>
        <link>http://localhost:4000/2016/04/runloop-programing-guide/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/04/runloop-programing-guide/</guid>
        
        <category>Runloop</category>
        
        <category>Thread Programming</category>
        
        
      </item>
    
      <item>
        <title>Runloop内存结构</title>
        <description>&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;```json
&amp;lt;CFRunLoop 0x7fb9f1600540 [0x10b29b7b0]&amp;gt;
{
	wakeup port = 0x1503, stopped = false, ignoreWakeUps = false,
	current mode = UIInitializationRunLoopMode,
	common modes = &amp;lt;CFBasicHash 0x7fb9f1707ef0 [0x10b29b7b0]&amp;gt;
	{
		type = mutable set, count = 2,

		entries =&amp;gt;

			0 : &amp;lt;CFString 0x10c196270 [0x10b29b7b0]&amp;gt;{contents = &quot;UITrackingRunLoopMode&quot;}
			2 : &amp;lt;CFString 0x10b2bbb60 [0x10b29b7b0]&amp;gt;{contents = &quot;kCFRunLoopDefaultMode&quot;}
	},

	common mode items = &amp;lt;CFBasicHash 0x7fb9f1708bf0 [0x10b29b7b0]&amp;gt;
	{
		type = mutable set, count = 16,

		entries =&amp;gt;value_name: value,

			0 : &amp;lt;CFRunLoopSource 0x7fb9f16006b0 [0x10b29b7b0]&amp;gt;
			{
				signalled = No, valid = Yes, order = -1, context = &amp;lt;CFRunLoopSource context&amp;gt;
				{
					version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x10e82f779)
				}
			}

			1 : &amp;lt;CFRunLoopSource 0x7fb9f14008b0 [0x10b29b7b0]&amp;gt;
			{
				signalled = No, valid = Yes, order = 0, context = &amp;lt;CFMachPort 0x7fb9f170d9a0 [0x10b29b7b0]&amp;gt;
				{
					valid = Yes, port = 1e03, source = 0x7fb9f14008b0, callout = __IOHIDEventSystemClientQueueCallback (0x10d4b987e), context = &amp;lt;CFMachPort context 0x7fb9f170d6d0&amp;gt;
				}
			}

			2 : &amp;lt;CFRunLoopObserver 0x7fb9f1509250 [0x10b29b7b0]&amp;gt;
			{
				valid = Yes, activities = 0xa0, repeats = Yes, order = 2001000, callout = _afterCACommitHandler (0x10b44ea99), context = &amp;lt;CFRunLoopObserver context 0x7fb9f15027c0&amp;gt;
			}

			3 : &amp;lt;CFRunLoopSource 0x7fb9f15095d0 [0x10b29b7b0]&amp;gt;
			{
				signalled = No, valid = Yes, order = -1, context = &amp;lt;CFRunLoopSource context&amp;gt;
				{
					version = 0, info = 0x7fb9f15027c0, callout = _UIApplicationHandleEventQueue (0x10b41c2db)
				}
			}

			4 : &amp;lt;CFRunLoopSource 0x7fb9f1400990 [0x10b29b7b0]&amp;gt;
			{
				signalled = No, valid = Yes, order = 0, context = &amp;lt;CFMachPort 0x7fb9f170dc90 [0x10b29b7b0]&amp;gt;
				{
					valid = Yes, port = 1f03, source = 0x7fb9f1400990, callout = __IOHIDEventSystemClientAvailabilityCallback (0x10d4b9a2f), context = &amp;lt;CFMachPort context 0x7fb9f170d6d0&amp;gt;
				}
			}

			5 : &amp;lt;CFRunLoopObserver 0x7fb9f171c850 [0x10b29b7b0]&amp;gt;
			{
				valid = Yes, activities = 0xa0, repeats = Yes, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (0x10efba320), context = &amp;lt;CFRunLoopObserver context 0x0&amp;gt;
			}

			6 : &amp;lt;CFRunLoopObserver 0x7fb9f141aba0 [0x10b29b7b0]&amp;gt;
			{
				valid = Yes, activities = 0x20, repeats = Yes, order = 0, callout = _UIGestureRecognizerUpdateObserver (0x10b8fb6ab), context = &amp;lt;CFRunLoopObserver context 0x0&amp;gt;
			}

			9 : &amp;lt;CFRunLoopObserver 0x7fb9f1509030 [0x10b29b7b0]&amp;gt;
			{
				valid = Yes, activities = 0xa0, repeats = Yes, order = 1999000, callout = _beforeCACommitHandler (0x10b44ea54), context = &amp;lt;CFRunLoopObserver context 0x7fb9f15027c0&amp;gt;
			}

			12 : &amp;lt;CFRunLoopSource 0x7fb9f1600440 [0x10b29b7b0]&amp;gt;
			{
				signalled = No, valid = Yes, order = 0, context = &amp;lt;CFMachPort 0x7fb9f1600160 [0x10b29b7b0]&amp;gt;
				{
					valid = Yes, port = 1107, source = 0x7fb9f1600440, callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_ (0x10efca8a9), context = &amp;lt;CFMachPort context 0x0&amp;gt;
				}
			}

			16 : &amp;lt;CFRunLoopSource 0x7fb9f16009e0 [0x10b29b7b0]&amp;gt;
			{
				signalled = No, valid = Yes, order = -1, context = &amp;lt;CFRunLoopSource context&amp;gt;
				{
					version = 1, info = 0x2303, callout = PurpleEventCallback (0x10e831cb0)
				}
			}

			17 : &amp;lt;CFRunLoopObserver 0x7fb9f1509470 [0x10b29b7b0]&amp;gt;
			{
				valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10b41bc4e), context = &amp;lt;CFArray 0x7fb9f1509220 [0x10b29b7b0]&amp;gt;
				{
					type = mutable-small, count = 0, values = ()
				}
			}


			18 : &amp;lt;CFRunLoopSource 0x7fb9f1400a70 [0x10b29b7b0]&amp;gt;
			{
				signalled = No, valid = Yes, order = 1, context = &amp;lt;CFMachPort 0x7fb9f1502110 [0x10b29b7b0]&amp;gt;
				{
					valid = Yes, port = 1c03, source = 0x7fb9f1400a70, callout = __IOMIGMachPortPortCallback (0x10d4c1fce), context = &amp;lt;CFMachPort context 0x7fb9f15020a0&amp;gt;
				}
			}


			19 : &amp;lt;CFRunLoopSource 0x7fb9f149f4c0 [0x10b29b7b0]&amp;gt;
			{
				signalled = No, valid = Yes, order = 0, context = &amp;lt;CFRunLoopSource MIG Server&amp;gt;
				{
					port = 18187, subsystem = 0x10c17b920, context = 0x7fb9f171d400
				}
			}


			20 : &amp;lt;CFRunLoopSource 0x7fb9f1509100 [0x10b29b7b0]&amp;gt;
			{
				signalled = No, valid = Yes, order = 0, context = &amp;lt;CFRunLoopSource MIG Server&amp;gt;
				{
				 	port = 14855, subsystem = 0x10c168fe0, context = 0x0
			 	}
		 	}


			21 : &amp;lt;CFRunLoopSource 0x7fb9f140f900 [0x10b29b7b0]&amp;gt;
			{
				signalled = Yes, valid = Yes, order = 0, context = &amp;lt;CFRunLoopSource context&amp;gt;
				{
					version = 0, info = 0x7fb9f140f680, callout = FBSSerialQueueRunLoopSourceHandler (0x10ddeef60)
				}
			}


			22 : &amp;lt;CFRunLoopObserver 0x7fb9f1509390 [0x10b29b7b0]&amp;gt;
			{
				valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10b41bc4e), context = &amp;lt;CFArray 0x7fb9f1509220 [0x10b29b7b0]&amp;gt;
				{
					type = mutable-small, count = 0, values = ()
				}
			}
	},


	modes = &amp;lt;CFBasicHash 0x7fb9f1707f50 [0x10b29b7b0]&amp;gt;
	{
		type = mutable set, count = 5,

		entries =&amp;gt;

			2 : &amp;lt;CFRunLoopMode 0x7fb9f17096a0 [0x10b29b7b0]&amp;gt;
			{
				name = UITrackingRunLoopMode, port set = 0x1807, timer port = 0x1903,

				sources0 = &amp;lt;CFBasicHash 0x7fb9f1709600 [0x10b29b7b0]&amp;gt;
				{
					type = mutable set, count = 3,

					entries =&amp;gt;

						0 : &amp;lt;CFRunLoopSource 0x7fb9f16006b0 [0x10b29b7b0]&amp;gt;
						{
							signalled = No, valid = Yes, order = -1, context = &amp;lt;CFRunLoopSource context&amp;gt;
							{
								version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x10e82f779)
							}
						}

						1 : &amp;lt;CFRunLoopSource 0x7fb9f140f900 [0x10b29b7b0]&amp;gt;
						{
							signalled = Yes, valid = Yes, order = 0, context = &amp;lt;CFRunLoopSource context&amp;gt;
							{
								version = 0, info = 0x7fb9f140f680, callout = FBSSerialQueueRunLoopSourceHandler (0x10ddeef60)
							}
						}

						2 : &amp;lt;CFRunLoopSource 0x7fb9f15095d0 [0x10b29b7b0]&amp;gt;
						{
							signalled = No, valid = Yes, order = -1, context = &amp;lt;CFRunLoopSource context&amp;gt;
							{
								version = 0, info = 0x7fb9f15027c0, callout = _UIApplicationHandleEventQueue (0x10b41c2db)
							}
						}
				},

				sources1 = &amp;lt;CFBasicHash 0x7fb9f1709640 [0x10b29b7b0]&amp;gt;
				{
					type = mutable set, count = 7,

					entries =&amp;gt;

					0 : &amp;lt;CFRunLoopSource 0x7fb9f14008b0 [0x10b29b7b0]&amp;gt;
						{
							signalled = No, valid = Yes, order = 0, context = &amp;lt;CFMachPort 0x7fb9f170d9a0 [0x10b29b7b0]&amp;gt;
							{
								valid = Yes, port = 1e03, source = 0x7fb9f14008b0, callout = __IOHIDEventSystemClientQueueCallback (0x10d4b987e), context = &amp;lt;CFMachPort context 0x7fb9f170d6d0&amp;gt;
							}
						}

						1 : &amp;lt;CFRunLoopSource 0x7fb9f149f4c0 [0x10b29b7b0]&amp;gt;
						{
							signalled = No, valid = Yes, order = 0, context = &amp;lt;CFRunLoopSource MIG Server&amp;gt;
							{
								port = 18187, subsystem = 0x10c17b920, context = 0x7fb9f171d400
							}
						}

						4 : &amp;lt;CFRunLoopSource 0x7fb9f1600440 [0x10b29b7b0]&amp;gt;
						{
							signalled = No, valid = Yes, order = 0, context = &amp;lt;CFMachPort 0x7fb9f1600160 [0x10b29b7b0]&amp;gt;
							{
								valid = Yes, port = 1107, source = 0x7fb9f1600440, callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_ (0x10efca8a9), context = &amp;lt;CFMachPort context 0x0&amp;gt;
							}
						}

						6 : &amp;lt;CFRunLoopSource 0x7fb9f16009e0 [0x10b29b7b0]&amp;gt;
						{
							signalled = No, valid = Yes, order = -1, context = &amp;lt;CFRunLoopSource context&amp;gt;
							{
								version = 1, info = 0x2303, callout = PurpleEventCallback (0x10e831cb0)
							}
						}

						8 : &amp;lt;CFRunLoopSource 0x7fb9f1400a70 [0x10b29b7b0]&amp;gt;
						{
							signalled = No, valid = Yes, order = 1, context = &amp;lt;CFMachPort 0x7fb9f1502110 [0x10b29b7b0]&amp;gt;
							{
								valid = Yes, port = 1c03, source = 0x7fb9f1400a70, callout = __IOMIGMachPortPortCallback (0x10d4c1fce), context = &amp;lt;CFMachPort context 0x7fb9f15020a0&amp;gt;
							}
						}

						9 : &amp;lt;CFRunLoopSource 0x7fb9f1400990 [0x10b29b7b0]&amp;gt;
						{
							signalled = No, valid = Yes, order = 0, context = &amp;lt;CFMachPort 0x7fb9f170dc90 [0x10b29b7b0]&amp;gt;
							{
								valid = Yes, port = 1f03, source = 0x7fb9f1400990, callout = __IOHIDEventSystemClientAvailabilityCallback (0x10d4b9a2f), context = &amp;lt;CFMachPort context 0x7fb9f170d6d0&amp;gt;
							}
						}

						10 : &amp;lt;CFRunLoopSource 0x7fb9f1509100 [0x10b29b7b0]&amp;gt;
						{
							signalled = No, valid = Yes, order = 0, context = &amp;lt;CFRunLoopSource MIG Server&amp;gt;
							{
								port = 14855, subsystem = 0x10c168fe0, context = 0x0
							}
						}
				},

				observers = &amp;lt;CFArray 0x7fb9f15090d0 [0x10b29b7b0]&amp;gt;
				{
					type = mutable-small, count = 6, values = (

						0 : &amp;lt;CFRunLoopObserver 0x7fb9f1509390 [0x10b29b7b0]&amp;gt;
						{
							valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10b41bc4e), context = &amp;lt;CFArray 0x7fb9f1509220 [0x10b29b7b0]&amp;gt;
							{
								type = mutable-small, count = 0, values = ()
							}
						}

						1 : &amp;lt;CFRunLoopObserver 0x7fb9f141aba0 [0x10b29b7b0]&amp;gt;
						{
							valid = Yes, activities = 0x20, repeats = Yes, order = 0, callout = _UIGestureRecognizerUpdateObserver (0x10b8fb6ab), context = &amp;lt;CFRunLoopObserver context 0x0&amp;gt;
						}

						2 : &amp;lt;CFRunLoopObserver 0x7fb9f1509030 [0x10b29b7b0]&amp;gt;
						{
							valid = Yes, activities = 0xa0, repeats = Yes, order = 1999000, callout = _beforeCACommitHandler (0x10b44ea54), context = &amp;lt;CFRunLoopObserver context 0x7fb9f15027c0&amp;gt;
						}

						3 : &amp;lt;CFRunLoopObserver 0x7fb9f171c850 [0x10b29b7b0]&amp;gt;
						{
							valid = Yes, activities = 0xa0, repeats = Yes, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (0x10efba320), context = &amp;lt;CFRunLoopObserver context 0x0&amp;gt;
						}

						4 : &amp;lt;CFRunLoopObserver 0x7fb9f1509250 [0x10b29b7b0]&amp;gt;
						{
							valid = Yes, activities = 0xa0, repeats = Yes, order = 2001000, callout = _afterCACommitHandler (0x10b44ea99), context = &amp;lt;CFRunLoopObserver context 0x7fb9f15027c0&amp;gt;
						}

						5 : &amp;lt;CFRunLoopObserver 0x7fb9f1509470 [0x10b29b7b0]&amp;gt;
						{
							valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10b41bc4e), context = &amp;lt;CFArray 0x7fb9f1509220 [0x10b29b7b0]&amp;gt;
							{
								type = mutable-small, count = 0, values = ()
							}
						}
					)
				},

				timers = (null),

				currently 482974032 (936875103045) / soft deadline in: 1.84467431e+10 sec (@ -1) / hard deadline in: 1.84467431e+10 sec (@ -1)
			},

			3 : &amp;lt;CFRunLoopMode 0x7fb9f1600870 [0x10b29b7b0]&amp;gt;
			{
				name = GSEventReceiveRunLoopMode, port set = 0x2103, timer port = 0x2203,

				sources0 = &amp;lt;CFBasicHash 0x7fb9f1600790 [0x10b29b7b0]&amp;gt;
				{
					type = mutable set, count = 1,

					entries =&amp;gt;
						0 : &amp;lt;CFRunLoopSource 0x7fb9f16006b0 [0x10b29b7b0]&amp;gt;
						{
							signalled = No, valid = Yes, order = -1, context = &amp;lt;CFRunLoopSource context&amp;gt;
							{
								version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x10e82f779)
							}
						}
				},

				sources1 = &amp;lt;CFBasicHash 0x7fb9f1600220 [0x10b29b7b0]&amp;gt;
				{
					type = mutable set, count = 1,
					entries =&amp;gt;
						2 : &amp;lt;CFRunLoopSource 0x7fb9f1600b40 [0x10b29b7b0]&amp;gt;
						{
							signalled = No, valid = Yes, order = -1, context = &amp;lt;CFRunLoopSource context&amp;gt;
							{
								version = 1, info = 0x2303, callout = PurpleEventCallback (0x10e831cb0)
							}
						}
				},

				observers = (null),
				timers = (null),
				currently 482974032 (936876354235) / soft deadline in: 1.84467431e+10 sec (@ -1) / hard deadline in: 1.84467431e+10 sec (@ -1)
			},

			4 : &amp;lt;CFRunLoopMode 0x7fb9f1707cc0 [0x10b29b7b0]&amp;gt;
			{
				name = kCFRunLoopDefaultMode, port set = 0x1603, timer port = 0x1703,

				sources0 = &amp;lt;CFBasicHash 0x7fb9f1708c50 [0x10b29b7b0]&amp;gt;
				{
					type = mutable set, count = 3,

					entries =&amp;gt;
						0 : &amp;lt;CFRunLoopSource 0x7fb9f16006b0 [0x10b29b7b0]&amp;gt;
						{
							signalled = No, valid = Yes, order = -1, context = &amp;lt;CFRunLoopSource context&amp;gt;
							{
								version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x10e82f779)
							}
						}

						1 : &amp;lt;CFRunLoopSource 0x7fb9f140f900 [0x10b29b7b0]&amp;gt;
						{
							signalled = Yes, valid = Yes, order = 0, context = &amp;lt;CFRunLoopSource context&amp;gt;
							{
								version = 0, info = 0x7fb9f140f680, callout = FBSSerialQueueRunLoopSourceHandler (0x10ddeef60)
							}
						}

						2 : &amp;lt;CFRunLoopSource 0x7fb9f15095d0 [0x10b29b7b0]&amp;gt;
						{
							signalled = No, valid = Yes, order = -1, context = &amp;lt;CFRunLoopSource context&amp;gt;
							{
								version = 0, info = 0x7fb9f15027c0, callout = _UIApplicationHandleEventQueue (0x10b41c2db)
							}
						}
				},

				sources1 = &amp;lt;CFBasicHash 0x7fb9f1708c90 [0x10b29b7b0]&amp;gt;
				{
					type = mutable set, count = 7,
						entries =&amp;gt;

							0 : &amp;lt;CFRunLoopSource 0x7fb9f14008b0 [0x10b29b7b0]&amp;gt;
							{
								signalled = No, valid = Yes, order = 0, context = &amp;lt;CFMachPort 0x7fb9f170d9a0 [0x10b29b7b0]&amp;gt;
								{
									valid = Yes, port = 1e03, source = 0x7fb9f14008b0, callout = __IOHIDEventSystemClientQueueCallback (0x10d4b987e), context = &amp;lt;CFMachPort context 0x7fb9f170d6d0&amp;gt;
								}
							}

							1 : &amp;lt;CFRunLoopSource 0x7fb9f149f4c0 [0x10b29b7b0]&amp;gt;
							{
								signalled = No, valid = Yes, order = 0, context = &amp;lt;CFRunLoopSource MIG Server&amp;gt;
								{
								 	port = 18187, subsystem = 0x10c17b920, context = 0x7fb9f171d400
							 	}
							}

							4 : &amp;lt;CFRunLoopSource 0x7fb9f1600440 [0x10b29b7b0]&amp;gt;
							{
								signalled = No, valid = Yes, order = 0, context = &amp;lt;CFMachPort 0x7fb9f1600160 [0x10b29b7b0]&amp;gt;
								{
									valid = Yes, port = 1107, source = 0x7fb9f1600440, callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_ (0x10efca8a9), context = &amp;lt;CFMachPort context 0x0&amp;gt;
								}
							}

							6 : &amp;lt;CFRunLoopSource 0x7fb9f16009e0 [0x10b29b7b0]&amp;gt;
							{
								signalled = No, valid = Yes, order = -1, context = &amp;lt;CFRunLoopSource context&amp;gt;
								{
									version = 1, info = 0x2303, callout = PurpleEventCallback (0x10e831cb0)
								}
							}

							8 : &amp;lt;CFRunLoopSource 0x7fb9f1400a70 [0x10b29b7b0]&amp;gt;
							{
								signalled = No, valid = Yes, order = 1, context = &amp;lt;CFMachPort 0x7fb9f1502110 [0x10b29b7b0]&amp;gt;
								{
									valid = Yes, port = 1c03, source = 0x7fb9f1400a70, callout = __IOMIGMachPortPortCallback (0x10d4c1fce), context = &amp;lt;CFMachPort context 0x7fb9f15020a0&amp;gt;
								}
							}

							9 : &amp;lt;CFRunLoopSource 0x7fb9f1400990 [0x10b29b7b0]&amp;gt;
							{
								signalled = No, valid = Yes, order = 0, context = &amp;lt;CFMachPort 0x7fb9f170dc90 [0x10b29b7b0]&amp;gt;
								{
									valid = Yes, port = 1f03, source = 0x7fb9f1400990, callout = __IOHIDEventSystemClientAvailabilityCallback (0x10d4b9a2f), context = &amp;lt;CFMachPort context 0x7fb9f170d6d0&amp;gt;
								}
							}

							10 : &amp;lt;CFRunLoopSource 0x7fb9f1509100 [0x10b29b7b0]&amp;gt;
							{
								signalled = No, valid = Yes, order = 0, context = &amp;lt;CFRunLoopSource MIG Server&amp;gt;
								{
									port = 14855, subsystem = 0x10c168fe0, context = 0x0
								}
							}
				},


				observers = &amp;lt;CFArray 0x7fb9f15091f0 [0x10b29b7b0]&amp;gt;
				{
					type = mutable-small, count = 6, values = ( 0 : &amp;lt;CFRunLoopObserver 0x7fb9f1509390 [0x10b29b7b0]&amp;gt;
					{
						valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10b41bc4e), context = &amp;lt;CFArray 0x7fb9f1509220 [0x10b29b7b0]&amp;gt;
						{
							type = mutable-small, count = 0, values = ()
						}
					}

					1 : &amp;lt;CFRunLoopObserver 0x7fb9f141aba0 [0x10b29b7b0]&amp;gt;
					{
						valid = Yes, activities = 0x20, repeats = Yes, order = 0, callout = _UIGestureRecognizerUpdateObserver (0x10b8fb6ab), context = &amp;lt;CFRunLoopObserver context 0x0&amp;gt;
					}

					2 : &amp;lt;CFRunLoopObserver 0x7fb9f1509030 [0x10b29b7b0]&amp;gt;
					{
						valid = Yes, activities = 0xa0, repeats = Yes, order = 1999000, callout = _beforeCACommitHandler (0x10b44ea54), context = &amp;lt;CFRunLoopObserver context 0x7fb9f15027c0&amp;gt;
					}

					3 : &amp;lt;CFRunLoopObserver 0x7fb9f171c850 [0x10b29b7b0]&amp;gt;
					{
						valid = Yes, activities = 0xa0, repeats = Yes, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (0x10efba320), context = &amp;lt;CFRunLoopObserver context 0x0&amp;gt;
					}

					4 : &amp;lt;CFRunLoopObserver 0x7fb9f1509250 [0x10b29b7b0]&amp;gt;
					{
						valid = Yes, activities = 0xa0, repeats = Yes, order = 2001000, callout = _afterCACommitHandler (0x10b44ea99), context = &amp;lt;CFRunLoopObserver context 0x7fb9f15027c0&amp;gt;
					}

					5 : &amp;lt;CFRunLoopObserver 0x7fb9f1509470 [0x10b29b7b0]&amp;gt;
					{
						valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x10b41bc4e), context = &amp;lt;CFArray 0x7fb9f1509220 [0x10b29b7b0]&amp;gt;
						{
							type = mutable-small, count = 0, values = ()
						}
					}
				)},

				timers = &amp;lt;CFArray 0x7fb9f1710e60 [0x10b29b7b0]&amp;gt;
				{
					type = mutable-small, count = 1, values = (

						0 : &amp;lt;CFRunLoopTimer 0x7fb9f1710da0 [0x10b29b7b0]&amp;gt;
						{
							valid = Yes, firing = No, interval = 0, tolerance = 0, next fire date = 482974033 (1.42061698 @ 938298801176), callout = (Delayed Perform) UIApplication _accessibilitySetUpQuickSpeak (0x10a6d89f7 / 0x10b8429a6) (/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/UIKit.framework/UIKit), context = &amp;lt;CFRunLoopTimer context 0x7fb9f17113e0&amp;gt;
						}
					)
				},

				currently 482974032 (936876412387) / soft deadline in: 1.42238876 sec (@ 938298801176) / hard deadline in: 1.42238872 sec (@ 938298801176)
			},

			5 : &amp;lt;CFRunLoopMode 0x7fb9f140fa90 [0x10b29b7b0]&amp;gt;
			{
				name = UIInitializationRunLoopMode, port set = 0x2e13, timer port = 0x320b,
				sources0 = &amp;lt;CFBasicHash 0x7fb9f140fb40 [0x10b29b7b0]&amp;gt;
				{
					type = mutable set, count = 1,

					entries =&amp;gt;

						1 : &amp;lt;CFRunLoopSource 0x7fb9f140f900 [0x10b29b7b0]&amp;gt;
						{
							signalled = Yes, valid = Yes, order = 0, context = &amp;lt;CFRunLoopSource context&amp;gt;
							{
								version = 0, info = 0x7fb9f140f680, callout = FBSSerialQueueRunLoopSourceHandler (0x10ddeef60)
							}
						}
				},

				sources1 = &amp;lt;CFBasicHash 0x7fb9f140fb80 [0x10b29b7b0]&amp;gt;
				{
					type = mutable set, count = 0,
					entries =&amp;gt;
				},

				observers = &amp;lt;CFArray 0x7fb9f171c950 [0x10b29b7b0]&amp;gt;
				{
					type = mutable-small, count = 1, values = (
						0 : &amp;lt;CFRunLoopObserver 0x7fb9f171c850 [0x10b29b7b0]&amp;gt;
						{
							valid = Yes, activities = 0xa0, repeats = Yes, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv (0x10efba320), context = &amp;lt;CFRunLoopObserver context 0x0&amp;gt;
						}
				)},

				timers = (null),

				currently 482974032 (936878249475) / soft deadline in: 1.84467431e+10 sec (@ -1) / hard deadline in: 1.84467431e+10 sec (@ -1)
			},

			6 : &amp;lt;CFRunLoopMode 0x7fb9f150af20 [0x10b29b7b0]&amp;gt;
			{
				name = kCFRunLoopCommonModes, port set = 0x3e03, timer port = 0x3f03,
				sources0 = (null),
				sources1 = (null),
				observers = (null),
				timers = (null),
				currently 482974032 (936878364889) / soft deadline in: 1.84467431e+10 sec (@ -1) / hard deadline in: 1.84467431e+10 sec (@ -1)
			},

	}
}```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 21 Apr 2016 05:46:52 +0800</pubDate>
        <link>http://localhost:4000/2016/04/runloop-memory-struct/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/04/runloop-memory-struct/</guid>
        
        <category>Runloop</category>
        
        <category>Thread Programming</category>
        
        
      </item>
    
      <item>
        <title>ubuntu上搭建VPN</title>
        <description>&lt;p&gt;点对点隧道协议（PPTP）是VPN服务的一种最简单的实现协议，其它常见的VPN类型还有：使用IPsec的第2层隧道协议（L2TP/IPsec）、安全套接字隧道协议（SSL VPN）。本文主要讨论PPTP VPN服务在Ubuntu上的安装和配置。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;A.使用apt源服务来安装PPTPD服务&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get update
sudo apt-get install pptpd
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;B.安装完成之后编辑pptpd.conf配置文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo vi /etc/pptpd.conf

#确保如下选项的配置
option /etc/ppp/pptpd-option                    #指定PPP选项文件的位置
debug                                           #启用调试模式
localip 192.168.0.1                             #VPN服务器的虚拟ip
remoteip 192.168.0.200-238,192.168.0.245        #分配给VPN客户端的虚拟ip
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;C.编辑PPP选项配置文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo vi /etc/ppp/pptpd-options

#确保如下选项的配置
name pptpd                      #pptpd服务的名称
refuse-pap                      #拒绝pap身份认证模式
refuse-chap                     #拒绝chap身份认证模式
refuse-mschap                   #拒绝mschap身份认证模式
require-mschap-v2               #允许mschap-v2身份认证模式
require-mppe-128                #允许mppe 128位加密身份认证模式
ms-dns 8.8.8.8                  #使用Google DNS
ms-dns 8.8.4.4                  #使用Google DNS
proxyarp                        #arp代理
debug                           #调试模式
dump                            #服务启动时打印出所有配置信息
lock                            #锁定TTY设备
nobsdcomp                       #禁用BSD压缩模式
logfile /var/log/pptpd.log      #输出日志文件位置
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;D.编辑用户配置文件来添加用户&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo vi /etc/ppp/chap-secrets

#格式：用户名   服务类型   密码   分配的ip地址
test    *    1234    *
#第一个*代表服务可以是PPTPD也可以是L2TPD，第二个*代表随机分配ip
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;E.重启PPTPD服务&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo service pptpd restart
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;F.配置网络和路由规则 设置ipv4转发&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo sed -i 's/#net.ipv4.ip_forward=1/net.ipv4.ip_forward=1/g' /etc/sysctl.conf
sudo sysctl -p
设置iptables NAT转发

#注意这里eth0代表你的外网网卡，请用ifconfig查看或者咨询网络管理员
sudo iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE
#如果上面的命令报错,那么可以尝试以下的命令，其中xxx.xxx.xxx.xxx代表你的VPS外网ip地址
sudo iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j SNAT --to-source xxx.xxx.xxx.xxx
设置MTU来确保过大的包不会被丢弃（这个可以不做）


sudo iptables -I FORWARD -s 192.168.0.0/24 -p tcp --syn -i ppp+ -j TCPMSS --set-mss 1300
iptables的设置重启之后会取消，所以可以将上面的命令加入到/etc/rc.local来确保每次重启都会执行设置。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;G.至此设置全部完成，可以用任意一个客户端机器如MAC、PC或者手机来新建一个VPN连接使用用户test，密码1234进行测试。另外网上提供一种自动安装脚本，可以参见如下操作：&lt;/p&gt;
</description>
        <pubDate>Sat, 05 Mar 2016 21:24:15 +0800</pubDate>
        <link>http://localhost:4000/2016/03/install-vpn-on-ubuntu/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/03/install-vpn-on-ubuntu/</guid>
        
        <category>VPN</category>
        
        
      </item>
    
      <item>
        <title>如何让HexoServer 后台运行</title>
        <description>&lt;p&gt;在Hexo 工程目录下面创建一个app.js文件作为项目的启动文件,并将如下代码拷贝到文件中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var spawn = require('child_process').spawn;             // 注册nodeJs子进程
free = spawn('hexo', ['server', '-p 80']);              // 注入命令参数

free.stdout.on('data', function (data) {
    console.log('standard output:\n' + data);           // 捕获标准输出并将其打印到控制台
});

free.stderr.on('data', function (data) {
    console.log('standard error output:\n' + data);     // 捕获标准错误输出并将其打印到控制台  
});

free.on('exit', function (code, signal) {
    console.log('child process eixt ,exit:' + code);    // 注册子进程关闭事件
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装forever 或者 pm2 来启动该 Hexo Server,就可以了。&lt;/p&gt;
</description>
        <pubDate>Sun, 21 Feb 2016 23:26:16 +0800</pubDate>
        <link>http://localhost:4000/2016/02/hexoserver/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/02/hexoserver/</guid>
        
        <category>Hexo</category>
        
        <category>后台运行</category>
        
        
      </item>
    
      <item>
        <title>如何用正则表达式 解析 文本中的 表情标签并且渲染到界面上</title>
        <description>&lt;p&gt;最近在使用JSQMessage定制聊天界面的的时候发现，JSQMessage目前不支持表情的显示，所以要自己把表情的文本解析出来，并且显示在TextView上面。思路主要是 使用正则表达式解析，然后通过NSAttributeString进行重新拼装。&lt;/p&gt;

&lt;p&gt;表情文本大概长这个样子，让我们有个直观的认识&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HAHFHDJKSAHFDA[大哭]JFDSAJFKDSA[大笑]DJFLAJLFD[大哭]HAHFDKJASFHDASHFDJASHFKDAHSJFDASHFJD[大笑][大笑][大笑]HFDHAJKFHDJSAHFDSJKA
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其实仔细想想 并不是很复杂。以下为思路部分：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1、将字符串转换成可变字符串，然后逐个找出其中的表情文本
2、将找出来的表情符号，跟表情前面的非表情符号 放入到数组中去。
3、等待解析结束之后，通过NSMutableAttributeString将字符串拼接，如果是表情，则使用NSTextAttachment来组装NSAttributeString
4、拼接完成之后，创建一个不可滚动 不可交互的UITextView，使用textStorage进行拼接
5、使用sizeThatSize来适配 自己定义的矩形范围
6、添加到View上即可显示
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以下是代码部分：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UITextView *textView = [[UITextView alloc] init];
textView.scrollEnabled = NO;
textView.selectable = NO;
textView.userInteractionEnabled = NO;
textView.backgroundColor = [UIColor blueColor];

NSMutableString *emojiString = [NSMutableString stringWithFormat:@&quot;%@&quot;, @&quot;HAHFHDJKSAHFDA[大哭]JFDSAJFKDSA[大笑]DJFLAJLFD[大哭]HAHFDKJASFHDASHFDJASHFKDAHSJFDASHFJD[大笑][大笑][大笑]HFDHAJKFHDJSAHFDSJKA&quot;];

emojiString = [NSMutableString stringWithFormat:@&quot;%@&quot;, @&quot;[大哭][大哭][大哭][大哭][大哭][大哭][大哭][大哭][大哭][大哭][大哭][大哭][大哭][大哭][大哭][大哭][大哭][大哭][大哭][大哭][大哭][大哭][大哭][大哭]&quot;];

NSMutableAttributedString *mutableAttribute = [[NSMutableAttributedString alloc] init];
NSMutableArray *attributes = [NSMutableArray arrayWithCapacity:10];

NSString *regex = @&quot;\\[[^\\[|^\\]]+\\]&quot;;
NSRegularExpression *expression = [NSRegularExpression regularExpressionWithPattern:regex options:NSRegularExpressionCaseInsensitive error:nil];

NSTextCheckingResult *result = [expression firstMatchInString:emojiString options:NSMatchingReportProgress range:NSMakeRange(0, emojiString.length)];


while (result) {
    NSRange range = [result rangeAtIndex:0];

    NSString *prefixNotEmojiString = [emojiString substringToIndex:range.location];
    NSString *currentEmojiString = [emojiString substringWithRange:range];

    if (prefixNotEmojiString.length) {
        NSAttributedString *attributeString = [[NSAttributedString alloc] initWithString:prefixNotEmojiString attributes:@{NSAttachmentAttributeName:[UIFont fontWithName:@&quot;Arial&quot; size:16]}];
        [attributes addObject:attributeString];
    }

    if (currentEmojiString.length) {
        NSTextAttachment *attachment = [[NSTextAttachment alloc] init];
        attachment.image = [UIImage imageNamed:@&quot;ebg&quot;];
        attachment.bounds = CGRectMake(-5, -5, 20, 20);

        NSAttributedString *attributeString = [NSAttributedString attributedStringWithAttachment:attachment];
        [attributes addObject:attributeString];
    }

    [emojiString replaceCharactersInRange:NSMakeRange(0, range.location) withString:@&quot;&quot;];
    [emojiString replaceCharactersInRange:NSMakeRange(0, range.length) withString:@&quot;&quot;];
    result = [expression firstMatchInString:emojiString options:NSMatchingReportProgress range:NSMakeRange(0, emojiString.length)];
}

[attributes enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
    [mutableAttribute appendAttributedString:obj];
}];
[textView.textStorage appendAttributedString:mutableAttribute];

CGSize size = [textView sizeThatFits:CGSizeMake(240, CGFLOAT_MAX)];
CGRect frame = CGRectMake(100, 100, size.width, size.height);
textView.frame = frame;
[textView sizeToFit];

[self.view addSubview:textView];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面这段代码放到某一个ViewController中的ViewDidLoad中即可。但是现在代码就完了么?当然不是，写代码的时候一定想着代码的复用。我们可以为UITextView写一个关于表情的分类，也可以写一个工具类来完成表情字符串的解析，然后返回NSAttributeString，这样子代码就会比较好看一些了。&lt;/p&gt;
</description>
        <pubDate>Sun, 21 Feb 2016 23:10:42 +0800</pubDate>
        <link>http://localhost:4000/2016/02/regex-pattern-using-on-emotion/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/02/regex-pattern-using-on-emotion/</guid>
        
        <category>NSRegularExpression</category>
        
        <category>正则表达式</category>
        
        <category>表情</category>
        
        
      </item>
    
      <item>
        <title>Linux下安装NodeJS</title>
        <description>&lt;p&gt;前段时间在Amazon上申请了一台Ubuntu的Linux服务器，并且搭建了自己的Openfire服务器，同时，写了自己的XMPP客户端登录 注册，聊天的代码，实现了基本的通信。一台服务器总不能只开放一个端口来用，这样也太浪费了。果断想到搭建自己的Http服务器，如果在以前的话，二话不说先下载Tomcat，然后使用struts、Spring搭建自己的服务器。在以前 不懂 Java Servlet 或者 Php等后台开发的人 就很难搭建自己的服务器了。现在，NodeJS 成功解决了前端开发人员不懂后台的难题。NodeJS是基于 事件驱动机制、异步I/O的Javascript执行引擎。单线程，在IO密集型应用中表现出了很大的优势。今天我们就看一下如何在Linux系统下搭建NodeJS，以及NodeJS 模块管理 npm&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;第一种做法：(最简单)&lt;/p&gt;

&lt;p&gt;一、安装NodeJS&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install nodejs
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;二、安装npm&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install npm
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;三、查看是否安装成功&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nodejs -v
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;四、尝试NodeJS 语法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nodejs
&amp;gt;console.log('HelloWorld');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;就可以看到 在命令行中 打印出了 HelloWorld的字样。到这边NodeJS就安装成功了。
但是这种做法 造成的后果就是 在使用NodeJS的时候 命令都需要使用nodejs，感觉很不方便，我还是喜欢使用node -v这样的命令&lt;/p&gt;

&lt;p&gt;第二种做法：(最难)&lt;/p&gt;

&lt;p&gt;一、登录Linux终端&lt;/p&gt;

&lt;p&gt;登陆到Linux终端，进入/usr/local/src目录，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@ubuntu:~# cd /usr/local/src/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;二、获取NodeJS源码&lt;/p&gt;

&lt;p&gt;http://nodejs.org/dist/latest-v0.12.x/node-v0.12.10-linux-x64.tar.gz
目前最新版本的代码，你也可以去http://nodejs.org/dist/ 看一下有没有更新的版本。&lt;/p&gt;

&lt;p&gt;三、解压 并 安装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//解压
 sudo tar xvf node-v0.12.10-linux-x64.tar.gz

 安装
 cd node-v0.12.10-linux-x64
 cd bin
 pwd    //找到当前所在目录/usr/local/src/node-v0.12.10-linux-x64/bin

 //配置该Node的环境变量
 export PATH=$PATH:/usr/local/src/node-v0.12.10-linux-x64/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果要环境变量为永久存在,需要 vim /etc/profile 在该文件的最后一行加上&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//配置该Node的环境变量
 export PATH=$PATH:/usr/local/src/node-v0.12.10-linux-x64/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;四、查看是否安装成功&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;node -v
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;五、尝试NodeJS语法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;node
&amp;gt;console.log('HelloWorld');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;六、安装NPM&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install npm
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 21 Feb 2016 20:21:40 +0800</pubDate>
        <link>http://localhost:4000/2016/02/install-nodejs-on-linux/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/02/install-nodejs-on-linux/</guid>
        
        <category>NodeJS</category>
        
        
      </item>
    
      <item>
        <title>如何在Amazon上搭建openfire服务器</title>
        <description>&lt;p&gt;由于前段时间 通过本地搭建openfire服务器实现了客户端与Message的文本消息的通信，现在我想把服务器放在云端上运行，查了一下关于云服务器，包括阿里、腾讯 但是都比较贵，大约60-100元一个月吧..所以，转移目光发现，Amazon的EC2 可以免费试用一年的时间。&lt;/p&gt;

&lt;p&gt;果断先试试Amazon的服务器。除了注册的时候填写银行卡 需要扣1美元的费用，以后这一年内，如果你没有添加新的服务项的话，这8块钱就足够了。而注册完成之后只需要根据Amazon的向导一步步的完成就可以了。最终启动一个Linux的实例。剩下的就是安装服务器以及环境配置方面相关的工作了。&lt;/p&gt;

&lt;p&gt;通过ssh登录，进入到命令行系统。&lt;/p&gt;

&lt;p&gt;一、安装JDK&lt;/p&gt;

&lt;p&gt;使用如下命令安装openjdk-7-jre，java运行时环境&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install openjdk-7-jre-headless
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果以后想使用javac编译.java文件的话，最好把jdk也安装一下。这个JDK&lt;/p&gt;

&lt;p&gt;主要包括java的基础类、以及编译所需要的一些工具，比如jconsole、javac等等。使用如下命令安装jdk&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install openjdk-7-jdk
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在命令行中输入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;java
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;验证是否安装完成。&lt;/p&gt;

&lt;p&gt;在命令行中输入:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javac
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;验证 java的编译器是否安装完成。&lt;/p&gt;

&lt;p&gt;二、mysql 数据库的安装&lt;/p&gt;

&lt;p&gt;在命令行中输入,检测更新&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后同时安装mysql服务器端 以及 客户端&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install mysql-server mysql-client
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在server安装过程中，会出现让你输入mysql-server的root账号的密码，这个密码是需要记住的。要不然后面没办法登录mysql-server了。
安装完成之后，使用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql -u root -p
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;之后输入密码就可以进入到mysql的客户端命令模式下面了。&lt;/p&gt;

&lt;p&gt;三、下载openfire的zip包&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget -O openfire.tar.gz http://www.igniterealtime.org/downloadServlet?filename=openfire/openfire_3_9_3.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下载的路径就是你当前命令行所在的目录。&lt;/p&gt;

&lt;p&gt;然后我们需要把该gzip包解压。(后面解压的名称还得根据你本地的文件名来)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tar -xzvf openfire_3_9_3.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后，将该解压之后的目录 移动到 另外一个目录下面&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mv openfire /usr/lib/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后，需要开启openfire服务器。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd /usr/lib/openfire/bin/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;调用openfire脚本&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./openfire start
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样，openfire服务器就算是搭建完成了。&lt;/p&gt;

&lt;p&gt;四、为openfire创建数据库&lt;/p&gt;

&lt;p&gt;使用如下命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql -u root -p
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输入密码之后，进入mysql模式下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt; create database openfire;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果提示创建数据库成功，那么就不用管了。&lt;/p&gt;

&lt;p&gt;后面就需要配置openfire服务器 与 mysql服务器的关联了。&lt;/p&gt;

&lt;p&gt;五、配置openfire服务器&lt;/p&gt;

&lt;p&gt;在配置openfire服务器之前，我们需要在amazon的管理控制台，找到正在运行的instance，并且进入instance的管理界面，找到安全组。将9090端口开放(添加到入站规则里面去，协议类型选择自定义TCP协议)&lt;/p&gt;

&lt;p&gt;这样，我们通过Amazon分配给你的该主机的域名就可以 访问openfire的后台管理系统了。&lt;/p&gt;

&lt;p&gt;http://ec2-52-68-82-92.ap-northeast-1.compute.amazonaws.com:9090/&lt;/p&gt;

&lt;p&gt;注意，在openfire配置数据库的时候，选mysql，在选jdbc连接那一栏的hostname 只需要填写127.0.0.1即可，因为本身openfire服务器也是在那台amazon的系统上面。后面的admin的密码也是需要记住的。要不然进不去管理系统噢。
如果有客户端需要连接进来的话，我猜测还需要将5222、5223端口开放才可以。&lt;/p&gt;
</description>
        <pubDate>Sun, 21 Feb 2016 20:18:00 +0800</pubDate>
        <link>http://localhost:4000/2016/02/install-openfile-on-ecs/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/02/install-openfile-on-ecs/</guid>
        
        <category>Openfire</category>
        
        <category>Amazon</category>
        
        
      </item>
    
      <item>
        <title>ubuntu下的一些操作</title>
        <description>&lt;p&gt;问题一:如何修改Ubuntu的root密码&lt;/p&gt;

&lt;p&gt;今天 注册了一个amazon的ec2 Ubuntu linux系统，因为 自己只需要在网页上面 配置一些选项，并且启动就可以了。所以，root用户以及密码 我还没有涉及修改。&lt;/p&gt;

&lt;p&gt;但是，现在要修改一些东西需要 用到Ubuntu的root权限，但是 自己又不记得在输入 su之后 又不知道密码是什么。这时候就需要命令去重置一下root的密码了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo passwd root
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再输入如下命令之后，terminal会有如下提示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Enter new UNIX password:
Retype new UNIX password:
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这时候，你只需要重新输入你的新密码就可以了。重置完成之后，输入su，根据提示 输入密码就能够进入root状态了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@ip-172-31-17-27:/home/ubuntu#
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这是比较实用的一招，记录下来以防以后用到。&lt;/p&gt;

&lt;p&gt;问题二：命令行如何登录mysql&lt;/p&gt;

&lt;p&gt;通过如下命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql -u root -p
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后输入密码就可以了。&lt;/p&gt;
</description>
        <pubDate>Sun, 21 Feb 2016 20:16:10 +0800</pubDate>
        <link>http://localhost:4000/2016/02/ubuntu-shell/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/02/ubuntu-shell/</guid>
        
        <category>ubuntu</category>
        
        
      </item>
    
      <item>
        <title>XMPP好友获取与好友关系详解</title>
        <description>&lt;p&gt;上篇主要讲解了关于XMPP登录部分，而登录部分 只用到了XMPPStream 连接，认证。而本篇 主要讲解 用户的注册(XMPPStream)、自己上线通知(XMPPPresence)、好友获取(IQ 请求)。&lt;/p&gt;

&lt;!-- more --&gt;
&lt;hr /&gt;

&lt;p&gt;用户注册部分&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;用户注册部分也比较简单。首先，我们需要自定义一个用户注册界面，界面的开发 就不在这边详细讲解了，github上面有开源的代码，你们可以去下载。xmpp的注册部分跟登录部分基本流程是相同的，xmpp注册 也需要先连接XMPP 服务器，当连接成功之后，需要调用XMPPStream的registe方法。我们来看一下具体实现：&lt;/p&gt;

&lt;p&gt;首先，跟登录类方法一样，我们需要先初始化一下xmppStream实例&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)initXMPPStream {
    self.registeXmppStream = [[XMPPStream alloc] init];
    [self.registeXmppStream addDelegate:self delegateQueue:dispatch_get_main_queue()];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;同时，使用本地已经创建的xmppStream 去发送连接服务器的请求&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#pragma mark -- register user
- (void)registeNewUserFromXMPPServer:(NSString *)userName password:(NSString *)password {
    self.userName = userName;
    self.password = password;

    NSString *myJid = [NSString stringWithFormat:@&quot;%@%@%@&quot;, userName, CONNECT_IDENTIFIER, HOST_NAME];
    self.registeXmppStream.myJID = [XMPPJID jidWithString:myJid];

    self.registeXmppStream.hostName = HOST_NAME;
    self.registeXmppStream.hostPort = HOST_PORT;

    NSError *connectError = nil;
    [self.registeXmppStream connectWithTimeout:TIME_OUT error:&amp;amp;connectError];
    if (connectError) {
        NSLog(@&quot;%@&quot;, connectError);
    }
}
其实，从上面的代码我们可以看出，这写代码跟登录的代码一模一样。后面才会看到不一样的地方
//xmpp连接成功之后，发送注册请求
- (void)xmppStreamDidConnect:(XMPPStream *)sender {
    NSError *registeError;
    [self.registeXmppStream registerWithPassword:self.password error:&amp;amp;registeError];
}

//注册成功之后，回调处理其他事情，比如跳转登录界面
- (void)xmppStreamDidRegister:(XMPPStream *)sender {
    [self.registeXMPPDelegate registeDidSuccess];
}

//注册失败之后应该如何处理
- (void)xmppStream:(XMPPStream *)sender didNotRegister:(NSXMLElement *)error {
    NSError *registerError = [NSError errorWithDomain:@&quot;regist xmpp&quot; code:-1 userInfo:@{@&quot;error&quot;:error.description}];
    [self.registeXMPPDelegate registeDidFailed:registerError];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们可以看到，登录模块 是在xmppStreamDidConnect的回调中 发起密码认证的报文，而在注册模块中，xmppStream连接成功之后，发起注册的报文，只有这一点不同而已。所以理解用户注册流程 也是非常容易的。
当注册成功之后，我们就可以用我们刚才注册的用户名 以及密码去登录了。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;获取联系人模块
—&lt;/p&gt;

&lt;p&gt;当我们登录成功之后，因为服务器并不会自动的下发给好友你的上线信息，需要自己发送一个报文 去告诉服务器 并且让服务器 转发给自己好友 自己的上线信息。所以，在登录成功之后，我们需要发送一个空的XMPPPresence，去告诉其他好友 我已经上线了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (void)sendOnLinePresence:(XMPPStream *)xmppStream {
    //如果没有类型，默认类型为available
    XMPPPresence *onLinePresence = [XMPPPresence presence];
    [xmppStream sendElement:onLinePresence];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;发送了这条Presence 出席消息给服务器之后，服务器会转发给你的好友，你好友的客户端会受到Presence报文，类型为available。好友就可以更新你的在线状态了。
发送了上线报文之后，我们需要去同步我们的好友信息，这时候我们还需要发送一个IQ请求，去请求好友列表。当然我们也可以初始化XMPPRoster 通过这个类去获取好友列表。本篇就不这样做了，我们还是需要了解一下xmpp 报文的详细信息的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/*
&amp;lt;iq type=&quot;get&quot;&amp;gt;
   &amp;lt;query xmlns=&quot;jabber:iq:roster&quot;/&amp;gt;
&amp;lt;/iq&amp;gt;
*/

+ (void)sendFetchRosterIQ:(XMPPStream *)xmppStream {
    NSXMLElement *query = [NSXMLElement elementWithName:@&quot;query&quot; xmlns:@&quot;jabber:iq:roster&quot;];

    XMPPIQ *iq = [XMPPIQ iqWithType:@&quot;get&quot; elementID:[xmppStream generateUUID]];
    [iq addChild:query];

    [xmppStream sendElement:iq];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样，我们通过这个方法 发送了请求好友的报文，服务器会返回给我们 好友信息。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;iq type=&quot;result&quot; id=&quot;F499F755-A8FA-4ED0-A839-185F0325A3A4&quot; to=&quot;test1@127.0.0.1/tvxw6qoij&quot;&amp;gt;&amp;lt;query xmlns=&quot;jabber:iq:roster&quot;&amp;gt;&amp;lt;item jid=&quot;test95&quot; name=&quot;terry&quot; subscription=&quot;both&quot;/&amp;gt;&amp;lt;item jid=&quot;test92&quot; name=&quot;maylor&quot; subscription=&quot;both&quot;/&amp;gt;&amp;lt;/query&amp;gt;&amp;lt;/iq&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们可以从上面服务器返回的报文中看到，我的好友有两个test95 和 test92. 名字也有。这样就完成了用户注册，上线报文发送 以及 好友获取模块的开发。&lt;/p&gt;

&lt;p&gt;在这里，其实我还想说一下联系人之间的关系，联系人 除了 上面报文里面 subscription=”both” 其实还有其他 几种格式。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1、Both：表示 我们是双向好友；即 我订阅了test92，当test92上线的时候，服务器会告诉我，test92已经上线。同时test92订阅了我，即当我上线的时候，我发送的上线报文，服务器会帮我转发给test92
2、to:表示我订阅了对方test92，即当test92上线的时候，test92发送上线报文给服务器，服务器会告诉我，test92上线了。但是我上线之后，服务器并不会告诉test92我上线了。
3、from:与to正好相反。
4、none：表示双方都没有相互订阅。即不是好友关系。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所以，很多人都说xmpp 报文比较重载，除了他登录与xmpp服务器交互多，xml 无用信息 多。而且包括 这一系列的冗余交互。本来 只需要一次交互就可以了。比如：我加你好友，你同意了。这样我们就是双向好友了，你删我了我们就变成单向好友了to。但是xmpp 必须是 你加(订阅)我了，我同意了。同时我加(订阅)你了，你也同意了，这样我们才是双向好友。
我也是醉了。如果要看最新的代码，请转到https://github.com/TerryLMay/TMXMPPClient/tree/master/TMXMPPClient&lt;/p&gt;
</description>
        <pubDate>Sun, 21 Feb 2016 20:14:16 +0800</pubDate>
        <link>http://localhost:4000/2016/02/xmpp-contact-query/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/02/xmpp-contact-query/</guid>
        
        <category>XMPP</category>
        
        
      </item>
    
      <item>
        <title>IOS XMPP客户端开发详解</title>
        <description>&lt;p&gt;由上篇文章将了如何在MAC本地搭建一个Openfire服务器，今天我们就要着手使用 XMPPFramework来开发 基于XMPP 协议的即时通讯IOS 客户端系统。今天主要看登录功能开发，可能有人会质疑，我们都没有开发注册功能，怎么开发登录功能。注册账号我们有捷径，服务器都在本地，当然很好做了。另外就是通过MAC 自带的客户端 Messages 进行注册。&lt;/p&gt;

&lt;p&gt;首先，我们需要搭建起来IOS 的工程，并且将XMPPFramework 引入到我们的工程中来,当然我们可以使用源码
直接导入，也可以使用cocoapods来进行依赖。本文直接使用源码来进行开发。由于在Github上的源码有一些问题，所以大家可以来https://github.com/TerryLMay/TMXMPPClient/tree/master/TMXMPPClient/ThirdTools/XMPPFrameworkio下载相关的XMPPFramework相关的代码。&lt;/p&gt;

&lt;p&gt;下载关于XMPPFramework的代码之后,我们需要做的是 创建一个工程，然后将源代码导入到我们的工程中去。当然直接导入并且编译会出现libxml找不到的问题。我们需要在工程中导入libxml2.tbd(ios 9之后的名称) 以及 libresolv.9.tbd(ios 9之后的后缀)。然后在Build Setting的Head search 中加上 头文件的链接地址
${SDKROOT}/usr/include/libxml2&lt;/p&gt;

&lt;p&gt;这之后，重新编译工程即可编译成功。后面，我们需要做的就是开发登录功能了，在开始之前，我们还是先看一下怎么注册一个账号吧；登录Openfire后台，创建一个用户。&lt;/p&gt;

&lt;p&gt;通过在浏览器中输入 (前提 是 openfire服务器以及mysql服务器都已经启动了)&lt;/p&gt;

&lt;p&gt;127.0.0.1:9090&lt;/p&gt;

&lt;p&gt;进入如下界面&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/blogImages/XMPPLogin/OpenFireServerHomePage.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击左上角用户/组 进入用户管理界面&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/blogImages/XMPPLogin/OpenfireUserHomePage.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后点击 左侧 导航栏中的新建用户 填写好用户信息就可以了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/blogImages/XMPPLogin/OpenfireCreateUserPage.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;到这边基本上用户注册环节 已经结束了。&lt;/p&gt;

&lt;p&gt;开发 登录功能，基本上包括 登录界面的开发、XMPP登录逻辑的开发。登录界面我们可以 随便搭建一个登录界面就可以了。我今天主要是说一下 XMPP登录部分。&lt;/p&gt;

&lt;p&gt;首先，创建关于XMPPLoginManager类，实现XMPPStreamDelegate，我定义了自己的一个宏，表示使用的Openfire服务器的地址 以及 端口号&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;```Objective-C
#define LocalOpenfire 1

#if LocalOpenfire

#define HOST_NAME @&quot;127.0.0.1&quot;
#define HOST_PORT 5222
#define CONNECT_IDENTIFIER @&quot;@&quot;

#endif

#define TIME_OUT 20

//然后 定义XMPPStream、XMPPReconnect实例，并且初始化
- (void)initXMPPStream {
    self.loginXmppStream = [[XMPPStream alloc] init];
    [self.loginXmppStream addDelegate:self delegateQueue:dispatch_get_main_queue()];
}

- (void)initXMPPReconnect {
    self.loginReconnectManager = [[XMPPReconnect alloc] init];
    [self.loginReconnectManager activate:self.loginXmppStream];
    // You can also optionally add delegates to the module.
    [self.loginReconnectManager addDelegate:self delegateQueue:dispatch_get_main_queue()];
}

//定义 Login按钮点击之后的点击事件调用 XMPPLoginManager中的如下方法进行连接：

#pragma mark -- connect xmpp method for login viewController
- (void)connectXMPPServer:(NSString *)userName password:(NSString *)password {
    self.userName = userName;
    self.password = password;

    NSString *myJid = [NSString stringWithFormat:@&quot;%@%@%@&quot;, userName, CONNECT_IDENTIFIER, HOST_NAME];
    self.loginXmppStream.myJID = [XMPPJID jidWithString:myJid];

    self.loginXmppStream.hostName = HOST_NAME;
    self.loginXmppStream.hostPort = HOST_PORT;

    NSError *connectError = nil;
    [self.loginXmppStream connectWithTimeout:TIME_OUT error:&amp;amp;connectError];

    if (connectError) {
        NSLog(@&quot;%@&quot;, connectError);
        [self.loginDelegate loginXMPPConnectError:connectError];
    }
}

//后面就是处理XMPPStream的各种回调就可以了

#pragma mark -- xmppstream delegate
//连接xmpp成功之后,使用密码认证
- (void)xmppStreamDidConnect:(XMPPStream *)sender {

    NSError *authError = nil;
    [self.loginXmppStream authenticateWithPassword:self.password error:&amp;amp;authError];

    if (authError) {
        NSLog(@&quot;%@&quot;, authError);
        [self.loginDelegate loginXMPPDidNotAuthenticate];
    }
}

//认证通过之后的处理
- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender {
    NSLog(@&quot;%@&quot;, @&quot;认证通过&quot;);
    [self.loginDelegate loginXMPPDidAuthenticate];
}

//连接服务器的超时处理
- (void)xmppStreamConnectDidTimeout:(XMPPStream *)sender {
    NSLog(@&quot;连接超时&quot;);
    [self.loginDelegate loginXMPPConnectDidTimeout];
}

//认证没有通过处理
- (void)xmppStream:(XMPPStream *)sender didNotAuthenticate:(DDXMLElement *)error {
    NSLog(@&quot;认证失败&quot;);
    [self.loginDelegate loginXMPPDidNotAuthenticate];
}
```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;基本上这样就可以登录了，登录成功之后，可以跳转到相应的界面。提一下我们 能看到的XMPP交互流程 包括：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1、XMPP 使用用户名去连接服务器；
2、XMPP 连接成功之后，通过密码去服务器认证
3、认证成功之后，处理自己想处理的一下事情。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但其实XMPP 报文交互包括好几步，我就从别人那边摘录一点交互细节过来，就不自己一个个的抓包看了。
C1: 客户端初始化流给服务器&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;stream:stream to=&quot;127.0.0.1&quot; xmlns=&quot;jabber:client&quot;
	xmlns:stream=&quot;http://etherx.jabber.org/streams&quot; version=&quot;1.0&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;S1: 服务器向客户端发送流标签作为应答:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version='1.0' encoding='UTF-8'?&amp;gt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;stream:stream&lt;/span&gt;
	&lt;span class=&quot;na&quot;&gt;xmlns:stream=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://etherx.jabber.org/streams&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jabber:client&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;from=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;192.168.1.185&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;fb0cfcad&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xml:lang=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;en&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;version=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1.0&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;S2: 发送 STARTTLS范围&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;stream:features&amp;gt;
&amp;lt;starttls xmlns=&quot;urn:ietf:params:xml:ns: xmpp-tls&quot;&amp;gt;&amp;lt;/starttls&amp;gt; &amp;lt;mechanisms xmlns=&quot;urn:ietf:params:xml:ns:xmpp-sasl&quot;&amp;gt;
&amp;lt;mechanism&amp;gt;PLAIN&amp;lt;/mechanism&amp;gt; &amp;lt;mechanism&amp;gt;CRAM-MD5&amp;lt;/mechanism&amp;gt; &amp;lt;mechanism&amp;gt;ANONYMOUS&amp;lt;/mechanism&amp;gt; &amp;lt;mechanism&amp;gt;DIGEST-MD5&amp;lt;/mechanism&amp;gt; &amp;lt;mechanism&amp;gt;JIVE-SHAREDSECRET&amp;lt;/mechanism&amp;gt; &amp;lt;/mechanisms&amp;gt;
&amp;lt;compression xmlns=&quot;http://jabber.org/features/compress&quot;&amp;gt;
&amp;lt;method&amp;gt;zlib&amp;lt;/method&amp;gt; &amp;lt;/compression&amp;gt;
&amp;lt;auth xmlns=&quot;http://jabber.org/features/iq-auth&quot;/&amp;gt;
&amp;lt;register xmlns=&quot;http://jabber.org/features/iq-register&quot;/&amp;gt; &amp;lt;/stream:features&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;C2:客户端发送 STARTTLS 命令给服务器:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;S3:服务器通知客户端可以继续进行:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;proceed xmlns='urn:ietf:params:xml:ns:xmpp-tls'/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;C3：TLS 握手成功, 客户端初始化一个新的流给服务器&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;stream:stream to=&quot;192.168.1.185&quot; xmlns=&quot;jabber:client&quot;
xmlns:stream=&quot;http://etherx.jabber.org/streams&quot; version=&quot;1.0&quot;&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;S4：服务器通知客户端可用的验证机制:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version='1.0' encoding='UTF-8'?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;stream:stream&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns:stream=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://etherx.jabber.org/streams&quot;&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jabber:client&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;from=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;192.168.1.185&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ad6f53e8&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xml:lang=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;en&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;version=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1.0&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;stream:features&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;mechanisms&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;urn:ietf:params:xml:ns:xmpp-sasl&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;mechanism&amp;gt;&lt;/span&gt;DIGEST-MD5&lt;span class=&quot;nt&quot;&gt;&amp;lt;/mechanism&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;mechanism&amp;gt;&lt;/span&gt;PLAIN&lt;span class=&quot;nt&quot;&gt;&amp;lt;/mechanism&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;mechanism&amp;gt;&lt;/span&gt;ANONYMOUS&lt;span class=&quot;nt&quot;&gt;&amp;lt;/mechanism&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;mechanism&amp;gt;&lt;/span&gt;CRAM-MD5&lt;span class=&quot;nt&quot;&gt;&amp;lt;/mechanism&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;/mechanisms&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;compression&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://jabber.org/features/compress&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;method&amp;gt;&lt;/span&gt;zlib&lt;span class=&quot;nt&quot;&gt;&amp;lt;/method&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;/compression&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;auth&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://jabber.org/features/iq-auth&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;register&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://jabber.org/features/iq-register&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;/stream:features&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;C4: 客户端选择一个验证机制:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;auth mechanism=&quot;DIGEST-MD5&quot; xmlns=&quot;urn:ietf:params:xml:ns:xmpp-sasl&quot;&amp;gt;&amp;lt;/auth&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;S5:服务器发送一个 [BASE64] 编码的挑战给客户端:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;challenge xmlns=&quot;urn:ietf:params:xml:ns:xmpp-sasl&quot;&amp;gt;cmVhbG09IjE5Mi4xNjguMS4xODUiLG5vbmNlPSJlcEJaZlBxU1p0WGlLYzBqdGpwT0I1a01HMHdiY0hsUmNhOE52ZE9SIixxb3A9ImF1dGgiLGNoYXJzZXQ9dXRmLTgsYWxnb3JpdGhtPW1kNS1zZXNz&amp;lt;/challenge&amp;gt;  C5:客户端发送一个[BASE64]编码的回应这个挑战:
&amp;lt;response xmlns=&quot;urn:ietf:params:xml:ns:xmpp-sasl&quot;&amp;gt;Y2hhcnNldD11dGYtOCx1c2VybmFtZT0iYWRtaW4iLHJlYWxtPSIxOTIuMTY4LjEuMTg1Iixub25jZT0iZXBCWmZQcVNadFhpS2MwanRqcE9CNWtNRzB3YmNIbFJjYThOdmRPUiIsbmM9MDAwMDAwMDEsY25vbmNlPSJMNDJ1SE1XK2piemh6N1hzdWRndHN1V1VIT2hNZmFLVUJpcU5iR1p2IixkaWdlc3QtdXJpPSJ4bXBwLzE5Mi4xNjguMS4xODUiLG1heGJ1Zj02NTUzNixyZXNwb25zZT1hN2JhMWZlOThiMDc2ZjUzZWUzNTczM2Q5NDMwODJlYSxxb3A9YXV0aCxhdXRoemlkPSJhZG1pbiI=&amp;lt;/response&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;S6:服务器通知客户端验证成功&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;success xmlns=&quot;urn:ietf:params:xml:ns:xmpp-sasl&quot;&amp;gt;cnNwYXV0aD0yNDZlZDcyOTQ3ZjVhYzFiNWQ2ZDc4ZTkxM2QzMmFjMQ==&amp;lt;/success&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;C6客户端初始化一个新流给服务器：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;stream:stream to=&quot;192.168.1.185&quot; xmlns=&quot;jabber:client&quot;
xmlns:stream=&quot;http://etherx.jabber.org/streams&quot; version=&quot;1.0&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;基本上XMPP的登录细节就已经清楚了。后面我们看一下 注册相关的模块 以及 联系人请求模块的开发。如果想获取源码的话，请转到https://github.com/TerryLMay/TMXMPPClient/tree/master/TMXMPPClient&lt;/p&gt;
</description>
        <pubDate>Sun, 21 Feb 2016 19:59:49 +0800</pubDate>
        <link>http://localhost:4000/2016/02/program-ios-xmpp-client/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/02/program-ios-xmpp-client/</guid>
        
        <category>XMPP</category>
        
        <category>报文</category>
        
        
      </item>
    
  </channel>
</rss>
